<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="cluster__hash_8cpp" kind="file">
    <compoundname>cluster_hash.cpp</compoundname>
    <includes local="no">string.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">stdio.h</includes>
    <includes local="no">time.h</includes>
    <includes local="no">math.h</includes>
    <includes local="yes">../zlib/uthash/src/uthash.h</includes>
    <includes refid="cluster__hash_8h" local="yes">../include/cluster_hash.h</includes>
    <incdepgraph>
      <node id="250">
        <label>/home/huijin/git/CCEX/src/cluster_hash.cpp</label>
        <link refid="cluster_hash.cpp"/>
        <childnode refid="251" relation="include">
        </childnode>
        <childnode refid="252" relation="include">
        </childnode>
        <childnode refid="253" relation="include">
        </childnode>
        <childnode refid="254" relation="include">
        </childnode>
        <childnode refid="255" relation="include">
        </childnode>
        <childnode refid="256" relation="include">
        </childnode>
        <childnode refid="257" relation="include">
        </childnode>
      </node>
      <node id="259">
        <label>stdint.h</label>
      </node>
      <node id="252">
        <label>stdlib.h</label>
      </node>
      <node id="257">
        <label>../include/cluster_hash.h</label>
        <link refid="cluster__hash_8h_source"/>
        <childnode refid="251" relation="include">
        </childnode>
        <childnode refid="252" relation="include">
        </childnode>
        <childnode refid="253" relation="include">
        </childnode>
        <childnode refid="254" relation="include">
        </childnode>
        <childnode refid="256" relation="include">
        </childnode>
        <childnode refid="258" relation="include">
        </childnode>
        <childnode refid="259" relation="include">
        </childnode>
        <childnode refid="260" relation="include">
        </childnode>
      </node>
      <node id="258">
        <label>stddef.h</label>
      </node>
      <node id="267">
        <label>bath.h</label>
        <link refid="bath_8h_source"/>
        <childnode refid="262" relation="include">
        </childnode>
        <childnode refid="268" relation="include">
        </childnode>
        <childnode refid="261" relation="include">
        </childnode>
      </node>
      <node id="268">
        <label>qubit.h</label>
        <link refid="qubit_8h_source"/>
        <childnode refid="262" relation="include">
        </childnode>
      </node>
      <node id="263">
        <label>Eigen/Dense</label>
      </node>
      <node id="256">
        <label>../zlib/uthash/src/uthash.h</label>
      </node>
      <node id="251">
        <label>string.h</label>
      </node>
      <node id="266">
        <label>unistd.h</label>
      </node>
      <node id="261">
        <label>general.h</label>
        <link refid="general_8h_source"/>
        <childnode refid="262" relation="include">
        </childnode>
      </node>
      <node id="254">
        <label>time.h</label>
      </node>
      <node id="255">
        <label>math.h</label>
      </node>
      <node id="264">
        <label>iostream</label>
      </node>
      <node id="260">
        <label>cluster.h</label>
        <link refid="cluster_8h_source"/>
        <childnode refid="261" relation="include">
        </childnode>
        <childnode refid="267" relation="include">
        </childnode>
        <childnode refid="262" relation="include">
        </childnode>
      </node>
      <node id="265">
        <label>mpi.h</label>
      </node>
      <node id="262">
        <label>utilities.h</label>
        <link refid="utilities_8h_source"/>
        <childnode refid="263" relation="include">
        </childnode>
        <childnode refid="264" relation="include">
        </childnode>
        <childnode refid="265" relation="include">
        </childnode>
        <childnode refid="266" relation="include">
        </childnode>
      </node>
      <node id="253">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="var">
      <memberdef kind="variable" id="cluster__hash_8cpp_1a6cfd95afd0afebd625b889fb6e58371c" prot="public" static="no" mutable="no">
        <type>int</type>
        <definition>int rank</definition>
        <argsstring></argsstring>
        <name>rank</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Rank of the process (MPI) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="10" column="1" bodyfile="/home/huijin/git/CCEX/main.cpp" bodystart="26" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="cluster__hash_8cpp_1a13654ad43b75218709e205850a41f85f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void clusterizeHash</definition>
        <argsstring>(Cluster *CCE, int nspin, int **spmap, float **stmap)</argsstring>
        <name>clusterizeHash</name>
        <param>
          <type><ref refid="structCluster" kindref="compound">Cluster</ref> *</type>
          <declname>CCE</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nspin</declname>
        </param>
        <param>
          <type>int **</type>
          <declname>spmap</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>stmap</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="12" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="12" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1ab2d03ad431ee0115b07f538a5844c162" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void freeHashCluster</definition>
        <argsstring>(HashCluster **hashClusters, int order)</argsstring>
        <name>freeHashCluster</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashClusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="57" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="57" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a237a61085a593a921c989c9ad778f47d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void convertClusinfoToHash</definition>
        <argsstring>(HashCluster **hashClusters, Cluster *CCE)</argsstring>
        <name>convertClusinfoToHash</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashClusters</declname>
        </param>
        <param>
          <type><ref refid="structCluster" kindref="compound">Cluster</ref> *</type>
          <declname>CCE</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="76" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="76" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1abebc71c366d2ca94c9f085a1316f0338" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int addCluster</definition>
        <argsstring>(HashCluster **hashClusters, int order, const char *id, int *spins, float strength, int count)</argsstring>
        <name>addCluster</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashClusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>id</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>spins</declname>
        </param>
        <param>
          <type>float</type>
          <declname>strength</declname>
        </param>
        <param>
          <type>int</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para><itemizedlist>
<listitem><para>Value assignment 2nd */ </para></listitem></itemizedlist>
</para>        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="112" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="112" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1ad1b54a9108e1b42f15f32d970e34f5fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int setMaxLengthStr</definition>
        <argsstring>(int nSpin, int order)</argsstring>
        <name>setMaxLengthStr</name>
        <param>
          <type>int</type>
          <declname>nSpin</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="155" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="155" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1aee631b4fe6a87df7efd1ade71a010a82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void makeHashClusterO1</definition>
        <argsstring>(HashCluster **hashclusters, int nspin)</argsstring>
        <name>makeHashClusterO1</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashclusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nspin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="161" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="161" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a6266836cf9a3bc5ad53fd367e09506e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void makeHashClusterO2</definition>
        <argsstring>(HashCluster **hashclusters, int nspin, int **spmap, float **stmap)</argsstring>
        <name>makeHashClusterO2</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashclusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nspin</declname>
        </param>
        <param>
          <type>int **</type>
          <declname>spmap</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>stmap</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="188" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="188" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1aff440b8597c83b6d13cc5a22f139b068" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void makeHashClusterOn</definition>
        <argsstring>(HashCluster **hashclusters, int order, int nspin, int **spmap, float **stmap, int *nks)</argsstring>
        <name>makeHashClusterOn</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashclusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nspin</declname>
        </param>
        <param>
          <type>int **</type>
          <declname>spmap</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>stmap</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nks</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="224" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="224" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a2e7e844007824dff536a437e679a8f70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void typeStr</definition>
        <argsstring>(char **destination, int *cluster, int order, int nSpin)</argsstring>
        <name>typeStr</name>
        <param>
          <type>char **</type>
          <declname>destination</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>cluster</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nSpin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="359" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="359" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a3c03f282af1a291fee41e3f0f21545d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int by_strength</definition>
        <argsstring>(const Property *a, const Property *b)</argsstring>
        <name>by_strength</name>
        <param>
          <type>const <ref refid="structProperty" kindref="compound">Property</ref> *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="structProperty" kindref="compound">Property</ref> *</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="371" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="371" bodyend="376"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a1c8b9255f31a154e48e5c8975a5b556d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> *</type>
        <definition>HashCluster* findCluster</definition>
        <argsstring>(HashCluster *hashClusters, int order)</argsstring>
        <name>findCluster</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> *</type>
          <declname>hashClusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="378" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="378" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a815ce025f3320bb1840b2942b7a6204f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structProperty" kindref="compound">Property</ref> *</type>
        <definition>Property* findProperty</definition>
        <argsstring>(HashCluster *hashClusters, int order, const char *id)</argsstring>
        <name>findProperty</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> *</type>
          <declname>hashClusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="390" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="390" bodyend="400"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1ab824186b80bbe281189462174e2c4698" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int binarySearch</definition>
        <argsstring>(int *arr, int low, int high, int target)</argsstring>
        <name>binarySearch</name>
        <param>
          <type>int *</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int</type>
          <declname>high</declname>
        </param>
        <param>
          <type>int</type>
          <declname>target</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="402" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="402" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a2c4c9395b42b8370c566cea0ec369942" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void addSpin</definition>
        <argsstring>(int **newcluster, int *oldcluster, int oldn, int spin)</argsstring>
        <name>addSpin</name>
        <param>
          <type>int **</type>
          <declname>newcluster</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>oldcluster</declname>
        </param>
        <param>
          <type>int</type>
          <declname>oldn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>spin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="419" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="419" bodyend="425"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a92aab7efa50c927df5e6ff090968fdfd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float minStrength</definition>
        <argsstring>(float currentStrength, float **strengthMap, int *oldcluster, int oldn, int newspin)</argsstring>
        <name>minStrength</name>
        <param>
          <type>float</type>
          <declname>currentStrength</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>strengthMap</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>oldcluster</declname>
        </param>
        <param>
          <type>int</type>
          <declname>oldn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>newspin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="427" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="427" bodyend="439"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a3d25f0062cfd81b8dda08a8a772570b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void printProperties</definition>
        <argsstring>(Property *hashProperties)</argsstring>
        <name>printProperties</name>
        <param>
          <type><ref refid="structProperty" kindref="compound">Property</ref> *</type>
          <declname>hashProperties</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="441" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="441" bodyend="462"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a38bab6a7e70e8f207f00872ab30e1a0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void printClusters</definition>
        <argsstring>(HashCluster *hashClusters)</argsstring>
        <name>printClusters</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> *</type>
          <declname>hashClusters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="464" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="464" bodyend="487"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a3679f0299f227492571e44be455cdb4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int *</type>
        <definition>int* parseClusterIdToIntArray</definition>
        <argsstring>(const char *id, int *count)</argsstring>
        <name>parseClusterIdToIntArray</name>
        <param>
          <type>const char *</type>
          <declname>id</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="490" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="490" bodyend="521"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a881bd0eb07e76afd42275803a1d0ca29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int countDigits</definition>
        <argsstring>(int number)</argsstring>
        <name>countDigits</name>
        <param>
          <type>int</type>
          <declname>number</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="524" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="524" bodyend="546"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a3c08100306289ee92372fad9d0142add" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int search2dArr</definition>
        <argsstring>(int **arr, int low, int high, int left, int right, int *target)</argsstring>
        <name>search2dArr</name>
        <param>
          <type>int **</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>low</declname>
        </param>
        <param>
          <type>int</type>
          <declname>high</declname>
        </param>
        <param>
          <type>int</type>
          <declname>left</declname>
        </param>
        <param>
          <type>int</type>
          <declname>right</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>target</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="548" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="548" bodyend="560"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a7519d1ca541c84a4268f1ca765d6f517" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void updateNk</definition>
        <argsstring>(int **Nk, int order, HashCluster *hashClusters)</argsstring>
        <name>updateNk</name>
        <param>
          <type>int **</type>
          <declname>Nk</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> *</type>
          <declname>hashClusters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="562" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="562" bodyend="581"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1ade82d5910aec868945bbfbaa657b3ed6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float addAllStrength</definition>
        <argsstring>(float currentStrength, float **strengthMap, int *oldcluster, int oldn, int newspin)</argsstring>
        <name>addAllStrength</name>
        <param>
          <type>float</type>
          <declname>currentStrength</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>strengthMap</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>oldcluster</declname>
        </param>
        <param>
          <type>int</type>
          <declname>oldn</declname>
        </param>
        <param>
          <type>int</type>
          <declname>newspin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="583" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="583" bodyend="591"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1aa9f95887c42a0e4f46ddeb04e68c914f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float</type>
        <definition>float addAllStrengthForAllSpins</definition>
        <argsstring>(float **strengthMap, int *cluster, int order)</argsstring>
        <name>addAllStrengthForAllSpins</name>
        <param>
          <type>float **</type>
          <declname>strengthMap</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>cluster</declname>
        </param>
        <param>
          <type>int</type>
          <declname>order</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="593" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="593" bodyend="603"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1ac0beb7777256cc3c7eb608b497503553" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void generateCombinations</definition>
        <argsstring>(int *arr, int ***data, int *tempCombination, int start, int end, int index, int r, int *nCombination)</argsstring>
        <name>generateCombinations</name>
        <param>
          <type>int *</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>int ***</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>tempCombination</declname>
        </param>
        <param>
          <type>int</type>
          <declname>start</declname>
        </param>
        <param>
          <type>int</type>
          <declname>end</declname>
        </param>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <param>
          <type>int</type>
          <declname>r</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>nCombination</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="606" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="606" bodyend="630"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1aa3b67c8c122faf40826b75bc6f0ef805" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void addSubClusters</definition>
        <argsstring>(HashCluster **hashclusters, int nspin, float **stmap, int n)</argsstring>
        <name>addSubClusters</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashclusters</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nspin</declname>
        </param>
        <param>
          <type>float **</type>
          <declname>stmap</declname>
        </param>
        <param>
          <type>int</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="632" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="632" bodyend="690"/>
      </memberdef>
      <memberdef kind="function" id="cluster__hash_8cpp_1a5b8dfb39c0c8b3592840e8a03797aaf4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void solveTilde</definition>
        <argsstring>(HashCluster **hashclusters, Cluster *CCE, int nspin)</argsstring>
        <name>solveTilde</name>
        <param>
          <type><ref refid="structHashCluster" kindref="compound">HashCluster</ref> **</type>
          <declname>hashclusters</declname>
        </param>
        <param>
          <type><ref refid="structCluster" kindref="compound">Cluster</ref> *</type>
          <declname>CCE</declname>
        </param>
        <param>
          <type>int</type>
          <declname>nspin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp" line="692" column="1" bodyfile="/home/huijin/git/CCEX/src/cluster_hash.cpp" bodystart="692" bodyend="799"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*<sp/>strcpy<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*<sp/>malloc<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>printf<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;time.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;math.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;../zlib/uthash/src/uthash.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;../include/cluster_hash.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>rank;</highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>clusterizeHash(<ref refid="structCluster" kindref="compound">Cluster</ref>*<sp/>CCE,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>spmap,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>stmap){</highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order<sp/>=<sp/>Cluster_getOrder(CCE);</highlight></codeline>
<codeline lineno="15"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>nks<sp/>=<sp/>Cluster_getNk(CCE);</highlight></codeline>
<codeline lineno="16"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>addsubclus<sp/>=<sp/>Cluster_getAddsubclus(CCE);</highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Clusterize</highlight></codeline>
<codeline lineno="21"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0){printf(</highlight><highlight class="stringliteral">&quot;\n\t<sp/>CCE1<sp/>...<sp/>\n&quot;</highlight><highlight class="normal">);}</highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*hashClusters<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/>makeHashClusterO1(&amp;hashClusters,nspin);</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/>updateNk(&amp;(nks),order,hashClusters);</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0){printf(</highlight><highlight class="stringliteral">&quot;\n\t<sp/>CCE2<sp/>...<sp/>\n&quot;</highlight><highlight class="normal">);}</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/>makeHashClusterO2(&amp;hashClusters,nspin,spmap,stmap);</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/>updateNk(&amp;(nks),order,hashClusters);</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Higher<sp/>order<sp/>clusters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/>makeHashClusterOn(&amp;hashClusters,order,nspin,spmap,stmap,nks);</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>updateNk(&amp;(nks),order,hashClusters);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0<sp/>&amp;&amp;<sp/>verbosity){</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printClusters(hashClusters);</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>all<sp/>sub<sp/>clusters</highlight></codeline>
<codeline lineno="39"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(addsubclus)<sp/>{</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=order;<sp/>n&gt;2;<sp/>n--){</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0){printf(</highlight><highlight class="stringliteral">&quot;\n\t<sp/>Add<sp/>subclusters<sp/>...<sp/>\n&quot;</highlight><highlight class="normal">);}</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addSubClusters(&amp;hashClusters,nspin,stmap,n);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>updateNk(&amp;(nks),order,hashClusters);</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Solve<sp/>tilde</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Here,<sp/>we&apos;ll<sp/>find<sp/>subclusters,<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>the<sp/>number<sp/>how<sp/>many<sp/>you<sp/>will<sp/>do<sp/>the<sp/>calculation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Additionally,<sp/>we<sp/>will<sp/>move<sp/>the<sp/>hashcluster<sp/>information</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>the<sp/>CCE-&gt;clusinfo</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/>solveTilde(&amp;hashClusters,CCE,nspin);</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/>freeHashCluster(&amp;hashClusters,order);</highlight></codeline>
<codeline lineno="55"><highlight class="normal">}</highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>freeHashCluster(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashClusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order){</highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=1;<sp/>n&lt;order+1;<sp/>n++){</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*existingClusters<sp/>=<sp/>findCluster(*hashClusters,n);</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*existingCluster,<sp/>*tmp;</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(existingClusters<sp/>!=<sp/>NULL){</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ITER(hh,existingClusters-&gt;prop,<sp/>existingCluster,<sp/>tmp)</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(existingCluster-&gt;spins);</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free((</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)existingCluster-&gt;id);</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_DEL(existingClusters-&gt;prop,existingCluster);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(existingClusters-&gt;prop);</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free((</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)existingClusters-&gt;N);</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_DEL(*hashClusters,existingClusters);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="74"><highlight class="normal">}</highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>convertClusinfoToHash(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashClusters,<sp/><ref refid="structCluster" kindref="compound">Cluster</ref>*<sp/>CCE){</highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order<sp/>=<sp/>Cluster_getOrder(CCE);</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin<sp/>=<sp/>Cluster_getClusinfo_ncluster(CCE,1);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=1;<sp/>n&lt;order+1;<sp/>n++){</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ncluster<sp/>=<sp/>Cluster_getClusinfo_ncluster(CCE,n);</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>length<sp/>=<sp/>ncluster+1;</highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=1;<sp/>i&lt;length;<sp/>i++){</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>iter<sp/>=<sp/>Cluster_getClusinfo_iter(CCE,n,i);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>cluster<sp/>=<sp/>Cluster_getClusinfo_cluster_copy(CCE,n,i);</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>strength<sp/>=<sp/>0.0;<sp/></highlight><highlight class="comment">//<sp/>Not<sp/>used<sp/>(because<sp/>we<sp/>don&apos;t<sp/>do<sp/>sort)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iter<sp/>!=<sp/>1){</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Error,convertClusinfoToHash,<sp/>iter<sp/>is<sp/>not<sp/>1<sp/>(It<sp/>already<sp/>has<sp/>been<sp/>processed<sp/>the<sp/>solveTilde<sp/>part)\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>make<sp/>id</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxlenId<sp/>=<sp/>setMaxLengthStr(nspin,n);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(maxlenId,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typeStr(&amp;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,cluster,n,nspin);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>cluster</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>addCluster(hashClusters,n,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,cluster,strength,iter);</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!res)<sp/>{</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;error,convertClusinfoToHash,<sp/>addcluster&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="109"><highlight class="normal">}</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>addCluster(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashClusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>spins,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>strength,</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count)</highlight></codeline>
<codeline lineno="113"><highlight class="normal">{</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>orderStr<sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(countDigits(order)+1,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(char));</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/>sprintf(orderStr,</highlight><highlight class="stringliteral">&quot;%d&quot;</highlight><highlight class="normal">,order);</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>overlapping<sp/>of<sp/>key<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*c;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>HASH_FIND_STR(*hashClusters,<sp/>orderStr,<sp/>c);</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*p;</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c<sp/>!=<sp/>NULL){</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_FIND_STR(c-&gt;prop,<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>p);</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Cluster<sp/>is<sp/>not<sp/>found*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c<sp/>==<sp/>NULL<sp/>||<sp/>p<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Build<sp/>new<sp/>Hashcluster<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c==NULL){</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>=<sp/>(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>*)malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>));</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c==NULL){</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Value<sp/>assignment<sp/>1st<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c-&gt;N<sp/>=<sp/>orderStr;</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c-&gt;prop<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ADD_KEYPTR(hh,<sp/>*hashClusters,<sp/>c-&gt;N,<sp/>strlen(c-&gt;N),<sp/>c);</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>(<ref refid="structProperty" kindref="compound">Property</ref>*)malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structProperty" kindref="compound">Property</ref>));</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;id<sp/>=<sp/>id;<sp/></highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;spins<sp/>=<sp/>spins;</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;strength<sp/>=<sp/>strength;</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;count<sp/>=<sp/>count;</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Add<sp/>new<sp/>Hashcluster*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ADD_KEYPTR(hh,<sp/>c-&gt;prop,<sp/>p-&gt;id,<sp/>strlen(p-&gt;id),<sp/>p);</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{<sp/></highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(orderStr);</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>cluster<sp/>already<sp/>exist,<sp/>so<sp/>we<sp/>cannot<sp/>add</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>cluster<sp/>is<sp/>successfully<sp/>added.<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="154"><highlight class="normal">}</highlight></codeline>
<codeline lineno="155"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>setMaxLengthStr(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nSpin,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order){</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nSpinDigit<sp/>=<sp/>countDigits(nSpin);</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*Additional<sp/>length<sp/>1<sp/>for<sp/>null*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(nSpinDigit*order)<sp/>+<sp/>(order-1)<sp/>+<sp/>(1);<sp/></highlight></codeline>
<codeline lineno="159"><highlight class="normal">}</highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>makeHashClusterO1(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashclusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin){</highlight></codeline>
<codeline lineno="162"><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;nspin;<sp/>i++)</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>single<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(1,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>single[0]<sp/>=<sp/>i;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>strength<sp/>=<sp/>0.0;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxlenId<sp/>=<sp/>setMaxLengthStr(nspin,n);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(maxlenId,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typeStr(&amp;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,single,n,nspin);</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>addCluster(hashclusters,n,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,single,strength,count);</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!res)<sp/>{</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;error,makeHashClusterO1,<sp/>addcluster&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="185"><highlight class="normal">}</highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>makeHashClusterO2(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashclusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>spmap,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>stmap){</highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>2;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res=0;</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>row=0;<sp/>row&lt;nspin;<sp/>row++)</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nConnectedSpins<sp/>=<sp/>spmap[row][0];</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>icol=1;<sp/>icol&lt;nConnectedSpins;<sp/>icol++)</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>col<sp/>=<sp/>spmap[row][icol];<sp/><sp/></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>pair<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(2,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pair[0]<sp/>=<sp/>row;</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pair[1]<sp/>=<sp/>col;</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(row&lt;col){</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>QuickSort(&amp;pair,0,1);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>strength<sp/>=<sp/>stmap[row][col];</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxlenId<sp/>=<sp/>setMaxLengthStr(nspin,n);</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(maxlenId,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typeStr(&amp;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,pair,n,nspin);</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>addCluster(hashclusters,n,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,pair,strength,count);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!res)<sp/>{</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;error,makeHashClusterO2,<sp/>addcluster&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>HASH_SORT(findCluster(*hashclusters,2)-&gt;prop,by_strength);</highlight></codeline>
<codeline lineno="221"><highlight class="normal">}</highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>makeHashClusterOn(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashclusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>spmap,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>stmap,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>nks){</highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=3;<sp/>n&lt;order+1;<sp/>n++){</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0){printf(</highlight><highlight class="stringliteral">&quot;\n\t<sp/>CCE%d<sp/>...<sp/>\n&quot;</highlight><highlight class="normal">,n);}</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>o<sp/>=<sp/>n-1;</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*existingClusters<sp/>=<sp/>findCluster(*hashclusters,o);</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;order<sp/>:<sp/>%s\n&quot;,<sp/>existingClusters<sp/>?<sp/>existingClusters-&gt;N<sp/>:<sp/>&quot;unknown\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*existingCluster,<sp/>*tmp;</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(existingClusters<sp/>!=<sp/>NULL){</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ITER(hh,existingClusters-&gt;prop,<sp/>existingCluster,<sp/>tmp)</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>take<sp/>one<sp/>cluster</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>%s\n&quot;,existingCluster-&gt;id);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;strength<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>%f\n&quot;,existingCluster-&gt;strength);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;current<sp/>cluster<sp/>:<sp/>%s\n&quot;,existingCluster-&gt;id);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>cluster<sp/>=<sp/>existingCluster-&gt;spins;</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>strength<sp/>=<sp/>existingCluster-&gt;strength;</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nPossibleSpins<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>possibleSpins<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(nPossibleSpins,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>possibleSpins[0]<sp/>=<sp/>nPossibleSpins;</highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nNewClusters<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>newClusters<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**)calloc(nNewClusters,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*));</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newClusters[0]<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(n,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newClusters[0][0]<sp/>=<sp/>nNewClusters;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>take<sp/>one<sp/>spin<sp/>in<sp/>a<sp/>cluster<sp/>to<sp/>find<sp/>connected<sp/>spins</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//clock_t<sp/>startTimeFindClusters,<sp/>endTimeFindClusters;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//startTimeFindClusters<sp/>=<sp/>clock();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;o;<sp/>i++){</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>spin<sp/>=<sp/>cluster[i];</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nConnectedSpins<sp/>=<sp/>spmap[spin][0];</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p=1;<sp/>p&lt;nConnectedSpins;<sp/>p++){</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>possibleSpin<sp/>=<sp/>spmap[spin][p];</highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>overlap<sp/>check<sp/>to<sp/>existing<sp/>cluster<sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>IsExistInCurrentCluster<sp/>=<sp/>binarySearch(cluster,0,o-1,possibleSpin);</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>overlap<sp/>check<sp/>to<sp/>PossibleSpin<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>IsExistInPossibleSpins<sp/>=<sp/>binarySearch(possibleSpins,1,nPossibleSpins-1,possibleSpin);</highlight></codeline>
<codeline lineno="270"><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;possible<sp/>spin<sp/>:<sp/>%2d<sp/>,<sp/>(judge<sp/>:<sp/>%2d,%2d<sp/>=&gt;<sp/>&quot;,possibleSpin,IsExistInCurrentCluster,IsExistInPossibleSpins);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsExistInCurrentCluster<sp/>==<sp/>-1<sp/>&amp;&amp;<sp/>IsExistInPossibleSpins<sp/>==<sp/>-1){</highlight></codeline>
<codeline lineno="273"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;<sp/>possible<sp/>)\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>possible<sp/>spin<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>possibleSpins<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)realloc(possibleSpins,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)*(nPossibleSpins+1));</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>possibleSpins[nPossibleSpins]<sp/>=<sp/>possibleSpin;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>potential<sp/>new<sp/>cluster</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>newClusterTmp<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(n,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="279"><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addSpin(&amp;newClusterTmp,<sp/>cluster,<sp/>o,<sp/>possibleSpin);</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>QuickSort(&amp;(newClusterTmp),0,n-1);</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>the<sp/>tempoaray<sp/>cluster<sp/>exist<sp/>in<sp/>the<sp/>created<sp/>cluster<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>IsExistInNewClusters<sp/>=<sp/>search2dArr(newClusters,1,nNewClusters-1,0,n-1,newClusterTmp);</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsExistInCurrentCluster<sp/>==<sp/>-1<sp/>){</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>NewCluster</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newClusters<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**)realloc(newClusters,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)*(nNewClusters+1));</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newClusters[nNewClusters]<sp/>=<sp/>newClusterTmp;</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>strength</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//float<sp/>newStrength<sp/>=<sp/>minStrength(strength,<sp/>stmap,<sp/>cluster,<sp/>o,<sp/>possibleSpin);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>newStrength<sp/>=<sp/>addAllStrength(strength,<sp/>stmap,<sp/>cluster,<sp/>o,<sp/>possibleSpin);</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxlenId<sp/>=<sp/>setMaxLengthStr(nspin,n);</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(maxlenId,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typeStr(&amp;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,newClusters[nNewClusters],n,nspin);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>add</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>addCluster(hashclusters,n,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,newClusters[nNewClusters],newStrength,count);</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nNewClusters++;</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{<sp/>free(newClusterTmp);<sp/>}</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nPossibleSpins++;</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>possibleSpins[0]<sp/>=<sp/>nPossibleSpins;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newClusters[0][0]<sp/>=<sp/>nNewClusters;</highlight></codeline>
<codeline lineno="312"><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(possibleSpins);</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_SORT(findCluster(*hashclusters,n)-&gt;prop,by_strength);</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//HASH_DELETE(hh2,potentialClusters,strongCluster);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printProperties(findCluster(*hashclusters,n)-&gt;prop);<sp/></highlight></codeline>
<codeline lineno="319"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>Cut<sp/>the<sp/>number<sp/>of<sp/>clusters<sp/>up<sp/>to<sp/>Nk</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//</highlight></codeline>
<codeline lineno="323"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*madeClusters,<sp/>*madeCluster,<sp/>*tmp;</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>madeClusters<sp/>=<sp/>findCluster(*hashclusters,n)-&gt;prop;</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nk<sp/>=<sp/>nks[n];</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nCluster<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nCluster<sp/>=<sp/>HASH_COUNT(madeClusters);</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nk<sp/>==<sp/>0){</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nk<sp/>=<sp/>nCluster;</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nCluster<sp/>&gt;<sp/>nk<sp/>){</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0){printf(</highlight><highlight class="stringliteral">&quot;\t\t<sp/>apply<sp/>Nk=%d<sp/>...<sp/>\n&quot;</highlight><highlight class="normal">,nk);}</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nCluster<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ITER(hh,<sp/>madeClusters,<sp/>madeCluster,<sp/>tmp)</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nCluster++;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nCluster<sp/>&gt;<sp/>nk){</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_DEL(madeClusters,madeCluster);</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nCluster<sp/>==<sp/>nk){;}</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(n<sp/>==<sp/>order){</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>message[500];</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sprintf(message,</highlight><highlight class="stringliteral">&quot;Warning,<sp/>during<sp/>making<sp/>clusters<sp/>of<sp/>%d<sp/>order,<sp/>made<sp/>clusters(%d)<sp/>is<sp/>smaller<sp/>than<sp/>given<sp/>nCluster(%d)&quot;</highlight><highlight class="normal">,n,nCluster,nk);</highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printMessage(message);</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{;}</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printProperties(findCluster(*hashclusters,n)-&gt;prop);<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="357"><highlight class="normal">}</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>typeStr(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>destination,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>cluster,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nSpin){</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nSpinDigit<sp/>=<sp/>countDigits(nSpin);</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;order;<sp/>i++){</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>str[nSpinDigit];</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sprintf(str,</highlight><highlight class="stringliteral">&quot;%d&quot;</highlight><highlight class="normal">,<sp/>cluster[i]);</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcat(*destination,str);</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i!=order-1){</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcat(*destination,</highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="369"><highlight class="normal">}</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>by_strength(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structProperty" kindref="compound">Property</ref>*<sp/>a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structProperty" kindref="compound">Property</ref>*<sp/>b)</highlight></codeline>
<codeline lineno="372"><highlight class="normal">{<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>descending<sp/>order<sp/>for<sp/>stregnth<sp/>(ex.<sp/>100<sp/>-<sp/>50<sp/>-<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(a-&gt;strength<sp/>==<sp/>b-&gt;strength)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>a-&gt;strength<sp/>&lt;<sp/>b-&gt;strength<sp/>?<sp/>1<sp/>:<sp/>-1;</highlight></codeline>
<codeline lineno="376"><highlight class="normal">}</highlight></codeline>
<codeline lineno="377"><highlight class="normal"></highlight></codeline>
<codeline lineno="378"><highlight class="normal"><ref refid="structHashCluster" kindref="compound">HashCluster</ref>*<sp/>findCluster(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>*<sp/>hashClusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order){</highlight></codeline>
<codeline lineno="379"><highlight class="normal"></highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>orderStr<sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(countDigits(order)+1,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(char));</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/>sprintf(orderStr,</highlight><highlight class="stringliteral">&quot;%d&quot;</highlight><highlight class="normal">,order);</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>overlapping<sp/>of<sp/>key<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*c;</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/>HASH_FIND_STR(hashClusters,<sp/>orderStr,<sp/>c);</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/>free(orderStr);</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>c;</highlight></codeline>
<codeline lineno="388"><highlight class="normal">}</highlight></codeline>
<codeline lineno="389"><highlight class="normal"></highlight></codeline>
<codeline lineno="390"><highlight class="normal"><ref refid="structProperty" kindref="compound">Property</ref>*<sp/>findProperty(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>*<sp/>hashClusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">){</highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*c<sp/>=<sp/>findCluster(hashClusters,order);</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*p;</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c<sp/>!=<sp/>NULL){</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_FIND_STR(c-&gt;prop,<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/>p);</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="400"><highlight class="normal">}</highlight></codeline>
<codeline lineno="401"><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>binarySearch(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>arr,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>low,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>high,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>target)<sp/>{</highlight></codeline>
<codeline lineno="403"><highlight class="normal"></highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(low<sp/>&lt;=<sp/>high)<sp/>{</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>mid<sp/>=<sp/>low<sp/>+<sp/>(high<sp/>-<sp/>low)<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(arr[mid]<sp/>==<sp/>target)</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>mid;</highlight></codeline>
<codeline lineno="409"><highlight class="normal"></highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(arr[mid]<sp/>&lt;<sp/>target)</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>low<sp/>=<sp/>mid<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>high<sp/>=<sp/>mid<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="415"><highlight class="normal"></highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;<sp/><sp/></highlight></codeline>
<codeline lineno="417"><highlight class="normal">}<sp/></highlight></codeline>
<codeline lineno="418"><highlight class="normal"></highlight></codeline>
<codeline lineno="419"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>addSpin(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>newcluster,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>oldcluster,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>oldn,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>spin){</highlight></codeline>
<codeline lineno="420"><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;oldn;<sp/>i++){<sp/></highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*newcluster)[i]<sp/>=<sp/>oldcluster[i];</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/>(*newcluster)[oldn]<sp/>=<sp/>spin;</highlight></codeline>
<codeline lineno="425"><highlight class="normal">}</highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>minStrength(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>currentStrength,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>strengthMap,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>oldcluster,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>oldn,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newspin){</highlight></codeline>
<codeline lineno="428"><highlight class="normal"></highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>newStrength<sp/>=<sp/>currentStrength;</highlight></codeline>
<codeline lineno="430"><highlight class="normal"></highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;oldn;<sp/>i++){<sp/></highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>spin<sp/>=<sp/>oldcluster[i];</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newStrength<sp/>&gt;<sp/>strengthMap[spin][newspin]){</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newStrength<sp/>=<sp/>strengthMap[spin][newspin];</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>newStrength;</highlight></codeline>
<codeline lineno="439"><highlight class="normal">}</highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>printProperties(<ref refid="structProperty" kindref="compound">Property</ref>*<sp/>hashProperties)</highlight></codeline>
<codeline lineno="442"><highlight class="normal">{</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*item2,<sp/>*tmp2;</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nCluster<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/>HASH_ITER(hh,<sp/>hashProperties,<sp/>item2,<sp/>tmp2)<sp/>{</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\t$items[%15s]<sp/>:<sp/>&quot;</highlight><highlight class="normal">,<sp/>item2-&gt;id);</highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>clusterFromId<sp/>=<sp/>parseClusterIdToIntArray(item2-&gt;id,&amp;count);</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=0;<sp/>i&lt;count;<sp/>i++){</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;%4d<sp/>&quot;</highlight><highlight class="normal">,item2-&gt;spins[i]);</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;<sp/>(strength<sp/>:<sp/>%12.5f)\n&quot;</highlight><highlight class="normal">,item2-&gt;strength);</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nCluster++;</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(clusterFromId);</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\tTotal<sp/>%d-Cluster<sp/>#<sp/>:<sp/><sp/>%d\n&quot;</highlight><highlight class="normal">,count,nCluster);</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\t_________________________________________________________\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="462"><highlight class="normal">}</highlight></codeline>
<codeline lineno="463"><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>printClusters(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>*<sp/>hashClusters)</highlight></codeline>
<codeline lineno="465"><highlight class="normal">{</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*item1,<sp/>*tmp1;</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*item2,<sp/>*tmp2;</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>HASH_ITER(hh,<sp/>hashClusters,<sp/>item1,<sp/>tmp1)<sp/>{</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nCluster<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ITER(hh,<sp/>item1-&gt;prop,<sp/>item2,<sp/>tmp2)<sp/>{</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\t$items[%3s][%10s]<sp/>:<sp/>&quot;</highlight><highlight class="normal">,<sp/>item1-&gt;N,<sp/>item2-&gt;id);</highlight></codeline>
<codeline lineno="472"><highlight class="normal"></highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>clusterFromId<sp/>=<sp/>parseClusterIdToIntArray(item2-&gt;id,&amp;count);</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=0;<sp/>i&lt;count;<sp/>i++){</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;%3d<sp/>&quot;</highlight><highlight class="normal">,item2-&gt;spins[i]);</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;<sp/>(strength<sp/>:<sp/>%10.5f)\n&quot;</highlight><highlight class="normal">,item2-&gt;strength);</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nCluster++;</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(clusterFromId);</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\tTotal<sp/>%s-Cluster<sp/>#<sp/>:<sp/><sp/>%d\n&quot;</highlight><highlight class="normal">,item1-&gt;N,nCluster);</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\t_________________________________________________________\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="487"><highlight class="normal">}</highlight></codeline>
<codeline lineno="488"><highlight class="normal"></highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Parse<sp/>a<sp/>string<sp/>into<sp/>an<sp/>array<sp/>of<sp/>integers</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>parseClusterIdToIntArray(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>count){</highlight></codeline>
<codeline lineno="491"><highlight class="normal"></highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Destination</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>intArray;</highlight></codeline>
<codeline lineno="494"><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Copy<sp/>the<sp/>input<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>strCopy<sp/>=<sp/>strdup(</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Convert<sp/>each<sp/>token<sp/>to<sp/>an<sp/>integer<sp/>and<sp/>store<sp/>it<sp/>in<sp/>the<sp/>array</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>token<sp/>=<sp/>strtok(strCopy,<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(token<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index<sp/>==<sp/>0){</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intArray<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(index+1,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intArray<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)realloc(intArray,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)*(index+1));</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Give<sp/>value<sp/>at<sp/>index<sp/>&quot;and<sp/>then&quot;<sp/>add<sp/>1<sp/>to<sp/>index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intArray[index]<sp/>=<sp/>atoi(token);</highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>token<sp/>=<sp/>strtok(NULL,<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index++;</highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="514"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Give<sp/>the<sp/>length<sp/>of<sp/>int<sp/>array</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/>*count<sp/>=<sp/>index;</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Set<sp/>the<sp/>count<sp/>of<sp/>the<sp/>resulting<sp/>array<sp/>and<sp/>free<sp/>the<sp/>memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/>free(strCopy);</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>intArray;</highlight></codeline>
<codeline lineno="521"><highlight class="normal">}</highlight></codeline>
<codeline lineno="522"><highlight class="normal"></highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/></highlight></codeline>
<codeline lineno="524"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>countDigits(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>number)<sp/>{</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="526"><highlight class="normal"></highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Handle<sp/>the<sp/>special<sp/>case<sp/>when<sp/>the<sp/>number<sp/>is<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(number<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="531"><highlight class="normal"></highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>negative<sp/>numbers,<sp/>convert<sp/>to<sp/>positive</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(number<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>number<sp/>=<sp/>-number;</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="536"><highlight class="normal"></highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(number<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Increment<sp/>the<sp/>count<sp/>for<sp/>each<sp/>digit</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline lineno="540"><highlight class="normal"></highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>the<sp/>last<sp/>digit<sp/>by<sp/>dividing<sp/>by<sp/>10</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>number<sp/>=<sp/>number<sp/>/<sp/>10;</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="544"><highlight class="normal"></highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>count;</highlight></codeline>
<codeline lineno="546"><highlight class="normal">}</highlight></codeline>
<codeline lineno="547"><highlight class="normal"></highlight></codeline>
<codeline lineno="548"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>search2dArr(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>arr,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>low,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>high,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>left,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>right,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>target)<sp/>{</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=low;<sp/>i&lt;=high;<sp/>i++){</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=left;<sp/>j&lt;=right;<sp/>j++){</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(arr[i][j]<sp/>==<sp/>target[j]){</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(count<sp/>==<sp/>right-left+1){</highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>i;}<sp/></highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;<sp/><sp/></highlight></codeline>
<codeline lineno="560"><highlight class="normal">}</highlight></codeline>
<codeline lineno="561"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>updateNk(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>Nk,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order,<sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref>*<sp/>hashClusters){</highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nk;</highlight></codeline>
<codeline lineno="565"><highlight class="normal"></highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*item,<sp/>*tmp;</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/>HASH_ITER(hh,<sp/>hashClusters,<sp/>item,<sp/>tmp){</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>atoi(item-&gt;N);</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nk<sp/>=<sp/>HASH_COUNT(item-&gt;prop);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*Nk)[k]<sp/>=<sp/>nk;</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="572"><highlight class="normal"></highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rank==0){</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\t\t<sp/>update<sp/>\&quot;Nk\&quot;\n\t\t<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;=order;<sp/>i++){</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;%d:%d<sp/><sp/>&quot;</highlight><highlight class="normal">,i,(*Nk)[i]);</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="579"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight></codeline>
<codeline lineno="581"><highlight class="normal">}</highlight></codeline>
<codeline lineno="582"><highlight class="normal"></highlight></codeline>
<codeline lineno="583"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>addAllStrength(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>currentStrength,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>strengthMap,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>oldcluster,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>oldn,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newspin){</highlight></codeline>
<codeline lineno="584"><highlight class="normal"></highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>addedStrength<sp/>=<sp/>currentStrength;</highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;oldn;<sp/>i++){<sp/></highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>spin<sp/>=<sp/>oldcluster[i];</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addedStrength+=strengthMap[spin][newspin];</highlight></codeline>
<codeline lineno="589"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>addedStrength;</highlight></codeline>
<codeline lineno="591"><highlight class="normal">}</highlight></codeline>
<codeline lineno="592"><highlight class="normal"></highlight></codeline>
<codeline lineno="593"><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>addAllStrengthForAllSpins(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>strengthMap,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>cluster,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>order){</highlight></codeline>
<codeline lineno="594"><highlight class="normal"></highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>addedStrength<sp/>=<sp/>0.0;<sp/></highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;order;<sp/>i++){<sp/></highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=i+1;<sp/>j&lt;order;<sp/>j++){<sp/></highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addedStrength+=strengthMap[cluster[i]][cluster[j]];</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="601"><highlight class="normal"></highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>addedStrength;</highlight></codeline>
<codeline lineno="603"><highlight class="normal">}</highlight></codeline>
<codeline lineno="604"><highlight class="normal"></highlight></codeline>
<codeline lineno="605"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Function<sp/>to<sp/>generate<sp/>combinations<sp/>and<sp/>store<sp/>them<sp/>in<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="606"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>generateCombinations(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>arr,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">***<sp/>data,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>tempCombination,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>start,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>end,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>r,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>nCombination)<sp/>{</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>combination<sp/>size<sp/>is<sp/>r,<sp/>copy<sp/>it<sp/>to<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index<sp/>==<sp/>r)<sp/>{</highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;nCombination<sp/>=<sp/>%d\n&quot;,*nCombination);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>r;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*data)[*nCombination][i]<sp/>=<sp/>tempCombination[i];</highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;%d<sp/>&quot;,(*data)[*nCombination][i]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*nCombination<sp/>+=<sp/>1;<sp/></highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="618"><highlight class="normal"></highlight></codeline>
<codeline lineno="619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>we<sp/>reach<sp/>the<sp/>end<sp/>of<sp/>the<sp/>array<sp/>or<sp/>the<sp/>desired<sp/>combination<sp/>size,<sp/>return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(start<sp/>==<sp/>end)<sp/>{</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="623"><highlight class="normal"></highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Include<sp/>the<sp/>current<sp/>element<sp/>in<sp/>the<sp/>combination</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/>tempCombination[index]<sp/>=<sp/>arr[start];</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/>generateCombinations(arr,<sp/>data,<sp/>tempCombination,<sp/>start<sp/>+<sp/>1,<sp/>end,<sp/>index<sp/>+<sp/>1,<sp/>r,<sp/>nCombination);</highlight></codeline>
<codeline lineno="627"><highlight class="normal"></highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Exclude<sp/>the<sp/>current<sp/>element<sp/>from<sp/>the<sp/>combination</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/>generateCombinations(arr,<sp/>data,<sp/>tempCombination,<sp/>start<sp/>+<sp/>1,<sp/>end,<sp/>index,<sp/>r,<sp/>nCombination);</highlight></codeline>
<codeline lineno="630"><highlight class="normal">}</highlight></codeline>
<codeline lineno="631"><highlight class="normal"></highlight></codeline>
<codeline lineno="632"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>addSubClusters(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashclusters,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin,<sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">**<sp/>stmap,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n){</highlight></codeline>
<codeline lineno="633"><highlight class="normal"></highlight></codeline>
<codeline lineno="634"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="635"><highlight class="normal"></highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*existingClusters<sp/>=<sp/>findCluster(*hashclusters,n);</highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*existingCluster,<sp/>*tmp;</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(existingClusters<sp/>!=<sp/>NULL){</highlight></codeline>
<codeline lineno="639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ITER(hh,existingClusters-&gt;prop,<sp/>existingCluster,<sp/>tmp)</highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>cluster<sp/>=<sp/>existingCluster-&gt;spins;</highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;cluster<sp/>:<sp/><sp/>%s\n&quot;,existingCluster-&gt;id);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>n-1;<sp/>r<sp/>&gt;=2;<sp/>r--){</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>subclusters</highlight></codeline>
<codeline lineno="647"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>number<sp/>of<sp/>combinations<sp/>(n<sp/>choose<sp/>r)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numCombinations<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>r;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numCombinations<sp/>*=<sp/>(n<sp/>-<sp/>i);</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numCombinations<sp/>/=<sp/>(i<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocate<sp/>memory<sp/>for<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>subclusters<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**)calloc(numCombinations,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*));</highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>numCombinations;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subclusters[i]<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(r,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>tempCombination<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(r,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));<sp/></highlight><highlight class="comment">//<sp/>Temporary<sp/>storage<sp/>for<sp/>combinations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nCombination<sp/>=<sp/>0<sp/>;</highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>generateCombinations(cluster,<sp/>&amp;subclusters,<sp/>tempCombination,<sp/>0,<sp/>n,<sp/>0,<sp/>r,<sp/>&amp;nCombination);</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Free<sp/>memory<sp/>for<sp/>tempCombination</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(tempCombination);<sp/></highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>subclusters</highlight></codeline>
<codeline lineno="666"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(nCombination=0;<sp/>nCombination&lt;numCombinations;<sp/>nCombination++){</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>QuickSort(&amp;(subclusters[nCombination]),0,r-1);</highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;subcluster[%2d]<sp/>:<sp/>&quot;,nCombination);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//for<sp/>(<sp/>int<sp/>k<sp/>=0;<sp/>k&lt;r;<sp/>k++){</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>printf(&quot;<sp/><sp/>%d&quot;,subclusters[nCombination][k]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;\n&quot;);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>strength</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>newStrength<sp/>=<sp/>addAllStrengthForAllSpins(stmap,<sp/>subclusters[nCombination],<sp/>r);</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxlenId<sp/>=<sp/>setMaxLengthStr(nspin,r);</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(maxlenId,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typeStr(&amp;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,subclusters[nCombination],r,nspin);</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>add</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>addCluster(hashclusters,r,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,subclusters[nCombination],newStrength,count);</highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!res){</highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(subclusters[nCombination]);</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="690"><highlight class="normal">}</highlight></codeline>
<codeline lineno="691"><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>solveTilde(<ref refid="structHashCluster" kindref="compound">HashCluster</ref>**<sp/>hashclusters,<ref refid="structCluster" kindref="compound">Cluster</ref>*<sp/>CCE,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nspin){</highlight></codeline>
<codeline lineno="693"><highlight class="normal"><sp/></highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n=CCE-&gt;<ref refid="structCluster_1ae77394af156e2e278a34f12e83d66cb7" kindref="member">order</ref>;<sp/>n&gt;=1;<sp/>n--){</highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structHashCluster" kindref="compound">HashCluster</ref><sp/>*existingClusters<sp/>=<sp/>findCluster(*hashclusters,n);</highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref><sp/>*existingCluster,<sp/>*tmp;</highlight></codeline>
<codeline lineno="697"><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nClusInfo<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="699"><highlight class="normal"></highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>HASH_ITER(hh,existingClusters-&gt;prop,<sp/>existingCluster,<sp/>tmp)</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>cluster<sp/>=<sp/>existingCluster-&gt;spins;</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;MAIN<sp/>CLUSTER<sp/>:<sp/>%s<sp/>\n&quot;,existingCluster-&gt;id);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cluster_count<sp/>=<sp/>existingCluster-&gt;count;</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cluster_count<sp/>!=<sp/>0){</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>cluster<sp/>that<sp/>you<sp/>will<sp/>find<sp/>its<sp/>sub-clusters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>allocate<sp/>memory<sp/>for<sp/>clusinfo</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CCE-&gt;<ref refid="structCluster_1afd65bde6cf52f123d1d1ab7a3fd9805c" kindref="member">clusinfo</ref>[n]<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**)realloc(CCE-&gt;<ref refid="structCluster_1afd65bde6cf52f123d1d1ab7a3fd9805c" kindref="member">clusinfo</ref>[n],(nClusInfo+1)*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*));</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CCE-&gt;<ref refid="structCluster_1afd65bde6cf52f123d1d1ab7a3fd9805c" kindref="member">clusinfo</ref>[n][nClusInfo]<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)calloc(n+1,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>value<sp/>assignment</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CCE-&gt;<ref refid="structCluster_1afd65bde6cf52f123d1d1ab7a3fd9805c" kindref="member">clusinfo</ref>[n][nClusInfo][0]<sp/>=<sp/>cluster_count;</highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=1;<sp/>i&lt;n+1;<sp/>i++){</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Here<sp/>i&apos;m<sp/>transfering<sp/>the<sp/>hashcluster<sp/>to<sp/>clusinfo</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>cluster[n]<sp/>=<sp/>{ispin,<sp/>jspin,<sp/>kspin,<sp/>...,<sp/>nspin}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>-1<sp/>of<sp/>cluster[i-1]<sp/>is<sp/>the<sp/>following:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>the<sp/>clusinfo<sp/>index<sp/>start<sp/>from<sp/>1<sp/>but<sp/>cluster<sp/>index<sp/>start<sp/>from<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>-1<sp/>of<sp/>cluster[i-1]<sp/>&quot;-1&quot;<sp/>is<sp/>the<sp/>following:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/>-1<sp/>for<sp/>actual<sp/>spin<sp/>index(BathArray)<sp/>is<sp/>starting<sp/>from<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CCE-&gt;<ref refid="structCluster_1afd65bde6cf52f123d1d1ab7a3fd9805c" kindref="member">clusinfo</ref>[n][nClusInfo][i]<sp/>=<sp/>cluster[i-1];<sp/></highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>number<sp/>of<sp/>clusters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CCE-&gt;<ref refid="structCluster_1afd65bde6cf52f123d1d1ab7a3fd9805c" kindref="member">clusinfo</ref>[n][0][0]<sp/>=<sp/>nClusInfo+1;</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>0-th<sp/>cluster<sp/>(qubit)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L0<sp/>(L1&apos;<sp/>L2&apos;<sp/>L3&apos;<sp/>L4&apos;)<sp/>(L12&apos;<sp/>L13&apos;<sp/>L24&apos;)<sp/>(L123&apos;<sp/>L124&apos;)<sp/>(&apos;<sp/>=<sp/>tilde)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L123&apos;<sp/>=<sp/>L123<sp/>/<sp/>(<sp/>(L0)<sp/>(L1&apos;<sp/>L2&apos;<sp/>L3&apos;)<sp/>(L12&apos;<sp/>L13&apos;<sp/>L23&apos;))<sp/>-&gt;<sp/>L0<sp/>count<sp/>=<sp/>-1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L124&apos;<sp/>=<sp/>L124<sp/>/<sp/>(<sp/>(L0)<sp/>(L1&apos;<sp/>L2&apos;<sp/>L4&apos;)<sp/>(L12&apos;<sp/>L14&apos;<sp/>L24&apos;))<sp/>-&gt;<sp/>L0<sp/>count<sp/>=<sp/>-1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L0^?<sp/>(L1&apos;^-1<sp/>L2&apos;^-1<sp/>)<sp/>(L12&apos;^-1<sp/>L14&apos;^-1<sp/>L23&apos;^-1)<sp/>L123<sp/>L124</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L23&apos;^-1<sp/>=<sp/>(L23<sp/>/<sp/>(<sp/>(L0)<sp/>(L2&apos;<sp/>L3&apos;)))^-1<sp/>-&gt;<sp/>L0<sp/>count<sp/>=<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L14&apos;^-1<sp/>=<sp/>(L14<sp/>/<sp/>(<sp/>(L0)<sp/>(L1&apos;<sp/>L4&apos;)))^-1<sp/>-&gt;<sp/>L0<sp/>count<sp/>=<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L12&apos;^-1<sp/>=<sp/>(L12<sp/>/<sp/>(<sp/>(L0)<sp/>(L1&apos;<sp/>L2&apos;)))^-1<sp/>-&gt;<sp/>L0<sp/>count<sp/>=<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L0^?<sp/>(L1&apos;^1<sp/>L2&apos;^1<sp/>L3&apos;^1<sp/>L4&apos;^1<sp/>)<sp/>L23<sp/>L14<sp/>L12<sp/>L123<sp/>L124</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>L0^?<sp/>(L1<sp/>L2<sp/>L3<sp/>L4<sp/>)<sp/>L23<sp/>L14<sp/>L12<sp/>L123<sp/>L124<sp/>-&gt;<sp/>L0<sp/>count<sp/>=<sp/>-1,<sp/>-1,<sp/>-1,<sp/>-1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Total<sp/>L0<sp/>count<sp/>=<sp/>-2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>CCE-&gt;clusinfo[0][0][0]<sp/>+=<sp/>-1<sp/>*<sp/>cluster_count;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nClusInfo++;</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>r<sp/>=<sp/>n-1;<sp/>r<sp/>&gt;=1;<sp/>r--){</highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>subclusters</highlight></codeline>
<codeline lineno="745"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>number<sp/>of<sp/>combinations<sp/>(n<sp/>choose<sp/>r)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numCombinations<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>r;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numCombinations<sp/>*=<sp/>(n<sp/>-<sp/>i);</highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numCombinations<sp/>/=<sp/>(i<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocate<sp/>memory<sp/>for<sp/>data</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**<sp/>subclusters<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">**)malloc(numCombinations<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*));</highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>numCombinations;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subclusters[i]<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)malloc(r<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>tempCombination<sp/>=<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)malloc(r<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));<sp/></highlight><highlight class="comment">//<sp/>Temporary<sp/>storage<sp/>for<sp/>combinations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nCombination<sp/>=<sp/>0<sp/>;</highlight></codeline>
<codeline lineno="758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>generateCombinations(cluster,<sp/>&amp;subclusters,<sp/>tempCombination,<sp/>0,<sp/>n,<sp/>0,<sp/>r,<sp/>&amp;nCombination);</highlight></codeline>
<codeline lineno="759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>print<sp/>subclusters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Free<sp/>memory<sp/>for<sp/>tempCombination</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(tempCombination);<sp/></highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>subclusters</highlight></codeline>
<codeline lineno="765"><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(nCombination=0;<sp/>nCombination&lt;numCombinations;<sp/>nCombination++){</highlight></codeline>
<codeline lineno="766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>sort</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>QuickSort(&amp;(subclusters[nCombination]),0,r-1);</highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>id<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>maxlenId<sp/>=<sp/>setMaxLengthStr(nspin,r);</highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)calloc(maxlenId,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typeStr(&amp;</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,subclusters[nCombination],r,nspin);</highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structProperty" kindref="compound">Property</ref>*<sp/>subcluster;</highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subcluster<sp/>=<sp/>findProperty(*hashclusters,r,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;subcluster<sp/>:<sp/>%s<sp/>\n&quot;,id);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(subcluster!=NULL){</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>subcluster-&gt;count<sp/>=<sp/>subcluster-&gt;count<sp/>-<sp/>cluster_count;</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CCE-&gt;<ref refid="structCluster_1a33621fac416bdd2eea40805e74730748" kindref="member">addsubclus</ref>){</highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&quot;Error,<sp/>subcluster<sp/>=<sp/>null\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(1);</highlight></codeline>
<codeline lineno="783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">{;</highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>strength<sp/>=<sp/>0.0;<sp/></highlight><highlight class="comment">//addAllStrengthForAllSpins(stmap,<sp/>subclusters[nCombination],<sp/>r);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>=<sp/>count<sp/>-<sp/>cluster_count;</highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>addCluster(hashclusters,r,</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,subclusters[nCombination],strength,count);</highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//free(id);<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//free(subclusters[nCombination]);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//free(subclusters);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight></codeline>
<codeline lineno="798"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="799"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/huijin/git/CCEX/src/cluster_hash.cpp"/>
  </compounddef>
</doxygen>
